#!/usr/bin/env ruby
# Author: Tom Santos
# http://github.com/tsantos/gitadm/tree/master

require 'optparse'
require 'ostruct'
require 'tempfile'

if ARGV.length == 0
	s = <<EOF
	
  gitadm is a tool for managing a git repositories.	 It does nothing for access control except to help
  with adding ssh keys.
	
  Usage:
    add-key               Adds a public key to the account on the specified server
    checkout              Checks out a branch with tracking
    create-remote-branch  Creates a new remote branch
    create-repo           Creates a new git repository

EOF
	puts s
	exit(1)
end

command = ARGV[0].gsub('-', '_').to_sym
ARGS = ARGV[1..-1] if ARGV.length > 1
options = OpenStruct.new
options.user = 'git'
options.server = 'git'

def user_opt opts, options
	opts.on('-u', '--user [USER]', "The git user on the machine. Defaults to 'git'.") do |user|
		options.user = user
	end
end

def server_opt opts, options
	opts.on('-s', '--server SERVER', "The host of the git repository.	 Defaults to 'git'.") do |server|
		options.server = server
	end
end

def help_opt opts
	opts.on("-h", "--help", "Show this message") do
		puts opts
		exit
	end
end

def create_branch_from_master branch_name, checkout = false
	`git push origin master:refs/heads/#{branch_name}`
	if checkout
		`git checkout --track -b #{branch_name} origin/#{branch_name}`
	end
end

=begin
	add-key
	We add a key to the authorized_keys file for the git account on the server.	 This will only
	work if you already have your key pushed to the server.	 It's intended as a way to add new keys
	for existing users.
=end
if :add_key == command
	opts = OptionParser.new do |opts|
		opts.banner = "Usage:"
		user_opt(opts, options)
		server_opt(opts, options)
		opts.on('-f', '--pub-key-file [FILE]', 'The file containing the public key(s)') do |path|
			options.pub_key_path = path
		end
		opts.on('-i', '--stdin', 'get the key(s) from stdin') do
			options.stdin = true
		end
		help_opt(opts)
	end
	if !defined? ARGS then puts opts; exit(1); end
	opts.parse! ARGS
	
	# Setup the key file to send
	file = nil
	
	if options.stdin
		file = Tempfile.new("gitadm")
		File.open(file.path, 'w') do |f|
			f.puts($stdin.readline)
		end
	elsif options.pub_key_path
		file = File.new(options.pub_key_path)
	end
	
	ssh = "ssh #{options.user}@#{options.server}"

	# Copy the key over as a temp file
	file_name = File.basename(file.path)
	`scp #{file.path} #{options.user}@#{options.server}:/tmp/#{file_name}`
	
	# Figure out which authorized_keys file they're using 
	auth_file = ".ssh/authorized_keys"
	auth_file = `#{ssh} '[ -f #{auth_file} ] && echo "#{auth_file}" || echo "#{auth_file}2"'`.strip
	
	# Get the key into the auth file and cleanup temp
	`#{ssh} 'cat /tmp/#{file_name} >> #{auth_file}'`
	`#{ssh} 'rm /tmp/#{file_name}'`

=begin
	checkout
	Checks out a branch with tracking enabled.	Basically just shorthand
=end
elsif :checkout == command
	opts = OptionParser.new do |opts|
		opts.banner = "Usage:"
		opts.on('-b', '--branch-name NAME', 'The branch name to check out') do |name|
			options.branch_name = name
		end
		help_opt(opts)
	end
	if !defined? ARGS then puts opts; exit(1); end
	opts.parse! ARGS
	
	`git checkout --track -b #{options.branch_name} origin/#{options.branch_name}`
	
=begin
	create-remote-branch
	Creates a remote branch.  You can use a local branch to base it from or you can default to
	the master.  You can also either setup tracking on your local branch or check it out with
	tracking if you chose to use master as your local branch.
=end
elsif :create_remote_branch == command
	options.local = :master
	
	opts = OptionParser.new do |opts|
		opts.banner = <<EOS
Examples:

This will use your local branch named 'dabranch' to make a new remote branch called 'dabranch'
and then it will set up the local branch to track the remote one that was created.

gitadm create-remote-branch -l dabranch -b dabranch -t

This will create a new remote branch called 'dabranch' based off master and then check it out
with tracking.

gitadm create-remote-branch -b dabranch -c

EOS
		opts.on('-l', '--local-branch NAME', 'The local branch to base it from.  Defaults to master.') do |name|
			options.local = name.to_sym
		end
		opts.on('-b', '--branch-name NAME', 'The branch name to create') do |name|
			options.branch_name = name
		end
		opts.on('-t', '--track', "Setup tracking. (doesn't apply if you used master)") do
			options.tracking = true
		end
		opts.on('-c', '--checkout', "Will check the branch out (only works if local branch was master)") do
			options.checkout = true
		end
		help_opt(opts)
	end
	if !defined? ARGS || !options.branch_name then puts opts; exit(1); end
	opts.parse! ARGS

	`git push origin #{options.local}:refs/heads/#{options.branch_name}`
	if options.checkout && options.local == :master
		`git checkout --track -b #{options.branch_name} origin/#{options.branch_name}`
	elsif options.tracking && options.local != :master
		`git config branch.#{options.local}.remote origin`
		`git config branch.#{options.local}.merge refs/heads/#{options.branch_name}`
	end

=begin
	create-repo
	Creates a new bare git repository at the given path.	It also allows you to send the current
	directory to the new repo and associates the repository and the local dir.	The --no-remote-create
	option is for sending the contents of a dir to to a place where the git repository has already been
	initialized like github.com.
=end
elsif :create_repo == command
	options.checkout = false
	
	opts = OptionParser.new do |opts|
		opts.banner = "Usage:"
		user_opt(opts, options)
		server_opt(opts, options)
		opts.on('-r', '--path-to-repo REPO', 'The path to the repository on the server. REQUIRED') do |path|
			options.repo_path = path
		end
		opts.on('-d', '--use-dir', "Associates the current dir with the new repo and sends the files") do
			options.use_dir = true
		end
		opts.on('-i', '--init', "Instead of --use-dir.	Init initializes the current dir but doesn't add all.	 You need to do git adds and a git push origin master before things will work.") do
			options.init = true
		end
		opts.on( "--no-remote-create", "Don't create the dirs on the remote machine" ) do
			options.no_remote_create = true
		end
		opts.on('-b', '--create-branches a,b,c', Array, "A comma separated list of branches") do |branches|
			options.branches = branches
		end
		opts.on('-c', '--checkout-branches', "Also does a checkout of the branches if using --create-branches") do
			options.checkout = true
		end
		help_opt(opts)
	end
	if !defined? ARGS || !options.repo_path then puts opts; exit(1); end
	opts.parse! ARGS
	
	# Make the new dir and init it
	unless options.no_remote_create
		ssh = "ssh #{options.user}@#{options.server}"
		`#{ssh} 'mkdir -p #{options.repo_path}'`
		`#{ssh} 'cd #{options.repo_path} ; git --bare init'`
	end
	
	# Upload dir contents and wire-up git pull and push
	if options.use_dir || options.init
		`git init`
		`git remote add origin #{options.user}@#{options.server}:#{options.repo_path}`
		if options.use_dir
			`git add * ; git commit -m "Initial commit"`
			`git push origin master`
		end
		`git config branch.master.remote origin ; git config branch.master.merge refs/heads/master`
		`git config push.default matching` # stop the new git from complaining
	end
	
	if options.branches
		options.branches.each { |branch| create_branch_from_master(branch, options.checkout) }
		`git checkout master` if options.checkout
	end
end
